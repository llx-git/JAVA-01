1. 串行 GC (Serial GC)
单线程的垃圾收集器，无法并行处理，当进行GC时，会触发STW，同时业务也无法处理，所以吞吐量也相对较小，适用于小内存的JVM或者单线程的CPU使用
优点：CPU利用率高
缺点：暂停时间长，无法利用多核CPU提高性能

2.并行 GC (Parallel GC)
并行垃圾收集器适用于多核处理器，在内存2-4G时使用，具有较高的吞吐量优势，但如果内存很大，会导致STW变长，GC回收变慢
java5~8的默认GC

3. CMS GC（Mostly Concurrent Mark and Sweep Garbage Collector）
并发垃圾收集器，设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：
1. 不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。
2. 在 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行。
也就是说，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢 CPU 时间。
默认情况下，CMS 使用的并发线程数等于 CPU 核心数的 1/4。 如果服务器是多核 CPU，并且主要调优目标是降低 GC 停顿导致的系统延迟，那么使用 CMS 是个很明智的选择。
进行老年代的并发回收时，可能会伴随着多次年轻代的 minor GC
六个阶段：
阶段 1: Initial Mark（初始标记）             标记所有可达对象（年轻代），会发生STW
阶段 2: Concurrent Mark（并发标记）          从年轻代标记的根对象算起，标记老年代可达对象
阶段 3: Concurrent Preclean（并发预清理）    记录初始标记后发生变化的脏区，进行卡片标记
阶段 4: Final Remark（最终标记）             最终确认可达对象，发生STW
阶段 5: Concurrent Sweep（并发清除）         删除所有无用对象
阶段 6: Concurrent Reset（并发重置）         重置CMS算法相关的内部数据

4. G1 GC （Garbage-First）
G1 最主要的设计目标是：将SWT停顿的事件和分布，变成可预期且可配置的。
G1 将堆内存划分为一个个的小区域，每个区域的性质会随时变化（老年代->新生代，新生代->老年代）
这样划分之后，使得 G1 不必每次都去收集整个堆空间，而是以增量的方式来进行处理: 每次只处理一部分内存块，称为此次 GC 的回收集(collection set)。
每次 GC 暂停都会收集所有年轻代的内存块，但一般只包含部分老年代 的内存块。
G1 的另一项创新是，在并发阶段估算每个小 堆块存活对象的总数。构建回收集的原则是： 垃圾最多的小块会被优先收集。这也是 G1 名 称的由来